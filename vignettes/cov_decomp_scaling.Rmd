---
title: "Fitting a Covariance Matrix Decomposition Using GBCD"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: no
    highlight: textmate
    theme: readable
vignette: >
  %\VignetteIndexEntry{Fitting a Covariance Matrix Decomposition Using GBCD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This vignette shows how to obtain a covariance decomposition using GBCD ("Generalized Binary Covariance Decomposition").

Suppose that we have an $N \times J$ matrix $Y$ of expression values with entries $y_{ij}$, where $i = 1, \dots, N$ indexes malignant cells and $j = 1, \dots, J$ indexes genes. In the vignette ["Dissecting tumor transcriptional heterogeneity from multi-tumor single-cell RNA-seq data using GBCD"][gbcd_hnscc], we show how to obtain a decomposition of the expression data matrix $Y$ into matrices $L$ and $F$ such that

$$
  y_{ij} \approx \sum_{k=1}^{K} l_{ik} f_{jk}.
$$

For more information on interpreting $l_{ik}$ and $f_{jk}$, please refer to that vignette.

In this vignette, we show how to obtain a decomposition of the scaled Gram matrix, $S = \frac{1}{J} YY'$ into matrix $L$ and diagonal matrix $D$ such that
$$
s_{ij} \approx \sum_{k=1}^{K}d_{kk}^2 l_{ik} l_{jk}.
$$

We refer to the above decomposition as a covariance decomposition because the scaled Gram matrix is the covariance matrix when the columns of $Y$ are centered. The elements $l_{ik} \geq 0$ each represent the membership of cell $i$ in GEP $k$. This decomposition allows us to capture differences between cells in a single matrix $L$.

First, we load the needed R packages. We also set a seed so that our results are reproducible.
```{r load-packages, message = FALSE}
library(Matrix)
library(ggplot2)
library(cowplot)
library(ggrepel)
library(pheatmap)
library(flashier)
library(gbcd)
library(ashr)
library(ebnm)
library(fastTopics)
set.seed(3)
```

# Toy Dataset
In this analysis, we will work with a toy dataset. We will generate a $n \times p$ data matrix $Y$ as follows:
$$ Y = LF' + E $$
where    
  
* $L$ is a $n \times 7$ tree-structured matrix  
* $F$ is a $p \times 7$ matrix with $F_{jk} \overset{i.i.d.}{\sim} N(0, 2)$   
* $E$ is a $n \times p$ error matrix with $E_{ij} \overset{i.i.d.}{\sim} N(0, 1)$.

This is the code to generate the data. This code was adapted from code written by Jason Willwerscheid for [Willwerscheid 2021][willwerscheid-2021]:
```{r simulate-data}
sim_4pops <- function(args) {
  set.seed(args$seed)
  
  n <- sum(args$pop_sizes)
  p <- args$n_genes
  
  FF <- matrix(rnorm(7 * p, sd = rep(args$branch_sds, each = p)), ncol = 7)
  
  LL <- matrix(0, nrow = n, ncol = 7)
  LL[, 1] <- 1
  LL[, 2] <- rep(c(1, 1, 0, 0), times = args$pop_sizes)
  LL[, 3] <- rep(c(0, 0, 1, 1), times = args$pop_sizes)
  LL[, 4] <- rep(c(1, 0, 0, 0), times = args$pop_sizes)
  LL[, 5] <- rep(c(0, 1, 0, 0), times = args$pop_sizes)
  LL[, 6] <- rep(c(0, 0, 1, 0), times = args$pop_sizes)
  LL[, 7] <- rep(c(0, 0, 0, 1), times = args$pop_sizes)
  
  E <- matrix(rnorm(n * p, sd = args$indiv_sd), nrow = n)
  Y <- LL %*% t(FF) + E
  YYt <- (1/p)*tcrossprod(Y)
  return(list(Y = Y, YYt = YYt, LL = LL, FF = FF, K = ncol(LL)))
}

sim_args = list(pop_sizes = rep(40, 4), n_genes = 1000, branch_sds = c(2,2,2,2,2,2,2), indiv_sd = 1, seed = 1)
sim_data <- sim_4pops(sim_args)
```

This is a heatmap of the scaled Gram matrix, $\frac{1}{p}YY'$:
```{r plot-obs-Gram}
cols <- colorRampPalette(c("gray96", "red"))(50)
brks <- seq(0, max(abs(sim_data$YYt)), length.out = 50)

pheatmap(sim_data$YYt, cluster_rows = FALSE,
         cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE,
         angle_col = 45, fontsize = 9, color = cols, breaks = brks, border_color = NA,
         main = "")
```

This is a heatmap of the true loadings matrix. Note this matrix is scaled such that each column has infinity norm equal to 1.:
```{r plot-loadings}
cols <- colorRampPalette(c("gray96", "red"))(50)
brks <- seq(0, max(abs(sim_data$LL)), length.out = 50)

pheatmap(sim_data$LL, cluster_rows = FALSE,
         cluster_cols = FALSE, show_rownames = FALSE, show_colnames = FALSE,
         angle_col = 45, fontsize = 9, color = cols, breaks = brks, border_color = NA, 
         main = "")
```

# Obtaining a Covariance Decomposition
Now, we use GBCD to obtain a covariance matrix decomposition.

## The `ldf_type` Argument
To obtain a covariance decomposition, we need to make use of the `ldf_type` argument. 

Recall that GBCD fits $Y \approx LF'$. Note that when the prior families for $L$ and $F$ are closed under scaling, the estimates of $L$ and $F$ are only identifiable up to a scaling. Therefore, an alternative way of framing the problem is fitting $Y \approx LDF'$ where $D$ is a diagonal matrix and $L$ is scaled so that each column has infinity norm equal to 1.

The `ldf_type` argument determines what diagonal scaling matrix $D$ is used when fitting $Y \approx LDF'$. The default setting is `ldf_type = i`, which sets $D$ to the identity matrix, and fits $L$ and $F$ accordingly. An alternative setting is `ldf_type = 'cov'`, which chooses $D$ such that $LD^2L' \approx \frac{1}{J}YY'$. To get a covariance matrix decomposition, we set `ldf_type = 'cov'`.

## Applying GBCD
We apply GBCD with `ldf_type = 'cov'`:
```{r gbcd-fit-cov}
cov_scaling_gbcd_fit <- fit_gbcd(sim_data$Y, Kmax = 7, prior = ebnm_generalized_binary, ldf_type = 'cov')
```

A few notes on the other arguments of this `fit_gbcd` call:   
   
* `prior = ebnm_generalized_binary` forces $L$ to be non-negative. Note that $D$ is non-negative by construction. So this generates a non-negative covariance matrix decomposition.    

* `Kmax = 7` forces the initialization step of GBCD to fit no more than 7 factors. However, it is possible for the final GBCD fit to have more than 7 factors (The number of factors in the GBCD fit will be no more than 2\*`Kmax`). It is recommended to set `Kmax` to a larger value rather than a smaller one. Here, we have set `Kmax = 7` because the true loadings matrix has 7 factors.

## Results
This is a structure plot of the scaled loadings estimate, $\tilde{L} = LD$:
```{r plot-cov-loadings}
pop_vec <- rep(c('A','B','C','D'), times = sim_args$pop_sizes)
L <- cov_scaling_gbcd_fit$L %*% diag(cov_scaling_gbcd_fit$D)
k <- ncol(L)
colnames(L) <- paste0("k",1:k)
p1 <- structure_plot(L,grouping = pop_vec,
                     gap = 16,verbose = FALSE) +
  labs(y = "membership",title = "GBCD - covariance decomposition scaling")
p1
```

By computing $LD^2L'$, we obtain an estimate for the observed scaled Gram matrix. We plot the off-diagonal entries of the fitted Gram matrix against the observed Gram matrix, and see that the entries closely match up.

```{r plot-cov-scale-fit-vs-obs}
Gram_est <- tcrossprod(cov_scaling_gbcd_fit$L %*% diag(cov_scaling_gbcd_fit$D))

off_diag_idx <- row(sim_data$YYt) != col(sim_data$YYt)

ggplot(data = NULL, aes(x = as.vector(sim_data$YYt[off_diag_idx]), y = as.vector(Gram_est[off_diag_idx]))) + geom_point() + geom_abline(slope = 1, intercept = 0, color = 'red') + xlab('Observed Gram Matrix Entries') + ylab('Fitted Gram Matrix Entries')
```

# Default GBCD
For comparison, we also analyze the data using the default `ldf_type = 'i'` setting.

```{r gbcd-fit-i}
i_scaling_gbcd_fit <- fit_gbcd(sim_data$Y, Kmax = 7, ebnm::ebnm_generalized_binary, ldf_type = 'i')
```

## Results
This is a structure plot of the loadings estimate, $L$ (Recall that for `ldf_type = 'i'`, $D$ is set to the identity matrix):
```{r plot-i-loadings}
L <- i_scaling_gbcd_fit$L
k <- ncol(L)
colnames(L) <- paste0("k",1:k)
p2 <- structure_plot(L,grouping = pop_vec,
                     gap = 16,verbose = FALSE) +
  labs(y = "membership",title = "GBCD - default scaling")
p2
```

With the default setting, we see that each component has a maximum loading value of 1. This can be helpful for interpreting the entries of the corresponding $F$ matrix. However, this estimate of $L$ (alone) cannot be used to generate an estimate for the Gram matrix, i.e $LL' \not\approx \frac{1}{J}YY'$. 

Here, we plot the off-diagonal entries of $LL'$ against the off-diagonal entries of the observed Gram matrix. We see that the entries are not of the same scale:
```{r plot-llt-vs-obs}
LLt <- tcrossprod(i_scaling_gbcd_fit$L)

ggplot(data = NULL, aes(x = as.vector(sim_data$YYt[off_diag_idx]), y = as.vector(LLt[off_diag_idx]))) + geom_point() + geom_abline(slope = 1, intercept = 0, color = 'red') + xlab('Observed Gram Matrix Entries') + ylab('LL\' Entries') + xlim(0,14) + ylim(0,14)
```

# Session Info
This is the version of R and the packages that were used to generate these results.

```{r session-info}
sessionInfo()
```

[willwerscheid-2021]: https://stephenslab.uchicago.edu/assets/papers/jason-thesis.pdf

[gbcd_hnscc]: https://stephenslab.github.io/gbcd/articles/hnscc.html
